initSidebarItems({"enum":[["PrimitiveType","The set of all implementations of the sealed trait [`NativeType`]."]],"mod":[["simd","Contains traits and implementations of multi-data used in SIMD. The actual representation is driven by the feature flag `\"simd\"`, which, if set, uses [`std::simd`]."]],"struct":[["BitChunkIter","An [`Iterator<Item=bool>`] over a [`BitChunk`]. This iterator is often compiled to SIMD. The LSB corresponds to the first slot, as defined by the arrow specification."],["BitChunkOnes","An [`Iterator<Item=usize>`] over a [`BitChunk`] returning the index of each bit set in the chunk Refer: https://lemire.me/blog/2018/03/08/iterating-over-set-bits-quickly-simd-edition/"],["IndexRange","Range of [`Index`], equivalent to `(a..b)`. `Step` is unstable in Rust, which does not allow us to implement (a..b) for [`Index`]."],["days_ms","The in-memory representation of the DayMillisecond variant of arrow’s “Interval” logical type."],["months_days_ns","The in-memory representation of the MonthDayNano variant of the “Interval” logical type."]],"trait":[["BitChunk","A chunk of bits. This is used to create masks of a given length whose width is `1` bit. In `simd_packed` notation, this corresponds to `m1xY`."],["Index","Sealed trait describing the subset of [`NativeType`] (`i32`, `i64`, `u32` and `u64`) that can be used to index a slot of an array."],["NativeType","Sealed trait implemented by all physical types that can be allocated, serialized and deserialized by this crate. All O(N) allocations in this crate are done for this trait alone."],["Offset","Sealed trait describing the subset (`i32` and `i64`) of [`Index`] that can be used as offsets of variable-length Arrow arrays."]]});
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A already configured CSV reader."><title>AsyncReader in arrow2::io::csv::read_async - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-deb46770fd761b69.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="arrow2" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0-nightly (09df6108c 2023-10-17)" data-channel="nightly" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-5f34af1a0ee6bacd.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../arrow2/index.html">arrow2</a><span class="version">0.17.4</span></h2></div><h2 class="location"><a href="#">AsyncReader</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.byte_headers">byte_headers</a></li><li><a href="#method.byte_records">byte_records</a></li><li><a href="#method.from_reader">from_reader</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_ref">get_ref</a></li><li><a href="#method.has_headers">has_headers</a></li><li><a href="#method.headers">headers</a></li><li><a href="#method.into_byte_records">into_byte_records</a></li><li><a href="#method.into_inner">into_inner</a></li><li><a href="#method.into_records">into_records</a></li><li><a href="#method.is_done">is_done</a></li><li><a href="#method.position">position</a></li><li><a href="#method.read_byte_record">read_byte_record</a></li><li><a href="#method.read_record">read_record</a></li><li><a href="#method.records">records</a></li><li><a href="#method.rewind">rewind</a></li><li><a href="#method.seek">seek</a></li><li><a href="#method.seek_raw">seek_raw</a></li><li><a href="#method.set_byte_headers">set_byte_headers</a></li><li><a href="#method.set_headers">set_headers</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Debug-for-AsyncReader%3CR%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-AsyncReader%3CR%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-AsyncReader%3CR%3E">Send</a></li><li><a href="#impl-Sync-for-AsyncReader%3CR%3E">Sync</a></li><li><a href="#impl-Unpin-for-AsyncReader%3CR%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-AsyncReader%3CR%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Allocation-for-T">Allocation</a></li><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In arrow2::io::csv::read_async</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../../index.html">arrow2</a>::<wbr><a href="../../index.html">io</a>::<wbr><a href="../index.html">csv</a>::<wbr><a href="index.html">read_async</a>::<wbr><a class="struct" href="#">AsyncReader</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct AsyncReader&lt;R&gt;(/* private fields */);</code></pre><span class="item-info"><div class="stab portability">Available on <strong>(crate features <code>io_csv_read</code> or <code>io_csv_read_async</code> or <code>io_csv_write</code>) and crate feature <code>io_csv_read_async</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A already configured CSV reader.</p>
<p>A CSV reader takes as input CSV data and transforms that into standard Rust
values. The reader reads CSV data is as a sequence of records,
where a record is a sequence of fields and each field is a string.</p>
<h2 id="configuration"><a href="#configuration">Configuration</a></h2>
<p>A CSV reader has convenient constructor method <code>from_reader</code>.
However, if you want to configure the CSV reader to use
a different delimiter or quote character (among many other things), then
you should use a <a href="struct.AsyncReaderBuilder.html"><code>AsyncReaderBuilder</code></a> to construct
a <code>AsyncReader</code>. For example, to change the field delimiter:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::AsyncReaderBuilder;

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city;country;pop
Boston;United States;4628910
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReaderBuilder::new()
        .delimiter(<span class="string">b&#39;;&#39;</span>)
        .create_reader(data.as_bytes());

    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.records();
    <span class="macro">assert_eq!</span>(records.next().<span class="kw">await</span>.unwrap()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h2 id="error-handling"><a href="#error-handling">Error handling</a></h2>
<p>In general, CSV <em>parsing</em> does not ever return an error. That is, there is
no such thing as malformed CSV data. Instead, this reader will prioritize
finding a parse over rejecting CSV data that it does not understand. This
choice was inspired by other popular CSV parsers, but also because it is
pragmatic. CSV data varies wildly, so even if the CSV data is malformed,
it might still be possible to work with the data. In the land of CSV, there
is no “right” or “wrong,” only “right” and “less right.”</p>
<p>With that said, a number of errors can occur while reading CSV data:</p>
<ul>
<li>By default, all records in CSV data must have the same number of fields.
If a record is found with a different number of fields than a prior
record, then an error is returned. This behavior can be disabled by
enabling flexible parsing via the <code>flexible</code> method on
<a href="struct.AsyncReaderBuilder.html"><code>AsyncReaderBuilder</code></a>.</li>
<li>When reading CSV data from a resource (like a file), it is possible for
reading from the underlying resource to fail. This will return an error.
For subsequent calls to the reader after encountering a such error
(unless <code>seek</code> is used), it will behave as if end of file had been
reached, in order to avoid running into infinite loops when still
attempting to read the next record when one has errored.</li>
<li>When reading CSV data into <code>String</code> or <code>&amp;str</code> fields (e.g., via a
<a href="struct.StringRecord.html"><code>StringRecord</code></a>), UTF-8 is strictly
enforced. If CSV data is invalid UTF-8, then an error is returned. If
you want to read invalid UTF-8, then you should use the byte oriented
APIs such as <a href="struct.ByteRecord.html"><code>ByteRecord</code></a>. If you need explicit
support for another encoding entirely, then you’ll need to use another
crate to transcode your CSV data to UTF-8 before parsing it.</li>
<li>When using Serde to deserialize CSV data into Rust types, it is possible
for a number of additional errors to occur. For example, deserializing
a field <code>xyz</code> into an <code>i32</code> field will result in an error.</li>
</ul>
<p>For more details on the precise semantics of errors, see the
<a href="enum.Error.html"><code>Error</code></a> type.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsyncReader%3CR%3E" class="impl"><a href="#impl-AsyncReader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'r, R&gt; <a class="struct" href="struct.AsyncReader.html" title="struct arrow2::io::csv::read_async::AsyncReader">AsyncReader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: AsyncRead + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'r,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_reader" class="method"><h4 class="code-header">pub fn <a href="#method.from_reader" class="fn">from_reader</a>(rdr: R) -&gt; <a class="struct" href="struct.AsyncReader.html" title="struct arrow2::io::csv::read_async::AsyncReader">AsyncReader</a>&lt;R&gt;</h4></section></summary><div class="docblock"><p>Create a new CSV parser with a default configuration for the given
reader.</p>
<p>To customize CSV parsing, use a <code>ReaderBuilder</code>.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::AsyncReader;

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.into_records();
    <span class="kw">while let </span><span class="prelude-val">Some</span>(record) = records.next().<span class="kw">await </span>{
        <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, record<span class="question-mark">?</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.records" class="method"><h4 class="code-header">pub fn <a href="#method.records" class="fn">records</a>(&amp;mut self) -&gt; StringRecordsStream&lt;'_, R&gt;</h4></section></summary><div class="docblock"><p>Returns a borrowed iterator over all records as strings.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;StringRecord, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::AsyncReader;

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.records();
    <span class="kw">while let </span><span class="prelude-val">Some</span>(record) = records.next().<span class="kw">await </span>{
        <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, record<span class="question-mark">?</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_records" class="method"><h4 class="code-header">pub fn <a href="#method.into_records" class="fn">into_records</a>(self) -&gt; StringRecordsIntoStream&lt;'r, R&gt;</h4></section></summary><div class="docblock"><p>Returns an owned iterator over all records as strings.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;StringRecord, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>This is mostly useful when you want to return a CSV iterator or store
it somewhere.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::AsyncReader;

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span>rdr = AsyncReader::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.into_records();
    <span class="kw">while let </span><span class="prelude-val">Some</span>(record) = records.next().<span class="kw">await </span>{
        <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, record<span class="question-mark">?</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_records" class="method"><h4 class="code-header">pub fn <a href="#method.byte_records" class="fn">byte_records</a>(&amp;mut self) -&gt; ByteRecordsStream&lt;'_, R&gt;</h4></section></summary><div class="docblock"><p>Returns a borrowed iterator over all records as raw bytes.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;ByteRecord, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::AsyncReader;

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>iter = rdr.byte_records();
    <span class="macro">assert_eq!</span>(iter.next().<span class="kw">await</span>.unwrap()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
    <span class="macro">assert!</span>(iter.next().<span class="kw">await</span>.is_none());
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_byte_records" class="method"><h4 class="code-header">pub fn <a href="#method.into_byte_records" class="fn">into_byte_records</a>(self) -&gt; ByteRecordsIntoStream&lt;'r, R&gt;</h4></section></summary><div class="docblock"><p>Returns an owned iterator over all records as raw bytes.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;ByteRecord, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>This is mostly useful when you want to return a CSV iterator or store
it somewhere.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::AsyncReader;

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span>rdr = AsyncReader::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>iter = rdr.into_byte_records();
    <span class="macro">assert_eq!</span>(iter.next().<span class="kw">await</span>.unwrap()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
    <span class="macro">assert!</span>(iter.next().<span class="kw">await</span>.is_none());
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.headers" class="method"><h4 class="code-header">pub async fn <a href="#method.headers" class="fn">headers</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;StringRecord, <a class="struct" href="struct.CSVError.html" title="struct arrow2::io::csv::read_async::CSVError">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a reference to the first row read by this parser.</p>
<p>If no row has been read yet, then this will force parsing of the first
row.</p>
<p>If there was a problem parsing the row or if it wasn’t valid UTF-8,
then this returns an error.</p>
<p>If the underlying reader emits EOF before any data, then this returns
an empty record.</p>
<p>Note that this method may be used regardless of whether <code>has_headers</code>
was enabled (but it is enabled by default).</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<p>This example shows how to get the header row of CSV data. Notice that
the header row does not appear as a record in the iterator!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::AsyncReader;

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(data.as_bytes());

    <span class="comment">// We can read the headers before iterating.
    </span>{
    <span class="comment">// `headers` borrows from the reader, so we put this in its
    // own scope. That way, the borrow ends before we try iterating
    // below. Alternatively, we could clone the headers.
    </span><span class="kw">let </span>headers = rdr.headers().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(headers, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    }

    {
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.records();
    <span class="macro">assert_eq!</span>(records.next().<span class="kw">await</span>.unwrap()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
    <span class="macro">assert!</span>(records.next().<span class="kw">await</span>.is_none());
    }

    <span class="comment">// We can also read the headers after iterating.
    </span><span class="kw">let </span>headers = rdr.headers().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(headers, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_headers" class="method"><h4 class="code-header">pub async fn <a href="#method.byte_headers" class="fn">byte_headers</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="struct.ByteRecord.html" title="struct arrow2::io::csv::read_async::ByteRecord">ByteRecord</a>, <a class="struct" href="struct.CSVError.html" title="struct arrow2::io::csv::read_async::CSVError">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a reference to the first row read by this parser as raw bytes.</p>
<p>If no row has been read yet, then this will force parsing of the first
row.</p>
<p>If there was a problem parsing the row then this returns an error.</p>
<p>If the underlying reader emits EOF before any data, then this returns
an empty record.</p>
<p>Note that this method may be used regardless of whether <code>has_headers</code>
was enabled (but it is enabled by default).</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<p>This example shows how to get the header row of CSV data. Notice that
the header row does not appear as a record in the iterator!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::AsyncReader;

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(data.as_bytes());

    <span class="comment">// We can read the headers before iterating.
    </span>{
    <span class="comment">// `headers` borrows from the reader, so we put this in its
    // own scope. That way, the borrow ends before we try iterating
    // below. Alternatively, we could clone the headers.
    </span><span class="kw">let </span>headers = rdr.byte_headers().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(headers, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    }

    {
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.byte_records();
    <span class="macro">assert_eq!</span>(records.next().<span class="kw">await</span>.unwrap()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
    <span class="macro">assert!</span>(records.next().<span class="kw">await</span>.is_none());
    }

    <span class="comment">// We can also read the headers after iterating.
    </span><span class="kw">let </span>headers = rdr.byte_headers().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(headers, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_headers" class="method"><h4 class="code-header">pub fn <a href="#method.set_headers" class="fn">set_headers</a>(&amp;mut self, headers: StringRecord)</h4></section></summary><div class="docblock"><p>Set the headers of this CSV parser manually.</p>
<p>This overrides any other setting (including <code>set_byte_headers</code>). Any
automatic detection of headers is disabled. This may be called at any
time.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>csv_async::{AsyncReader, StringRecord};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(data.as_bytes());

    <span class="macro">assert_eq!</span>(rdr.headers().<span class="kw">await</span><span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    rdr.set_headers(StringRecord::from(<span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]));
    <span class="macro">assert_eq!</span>(rdr.headers().<span class="kw">await</span><span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_byte_headers" class="method"><h4 class="code-header">pub fn <a href="#method.set_byte_headers" class="fn">set_byte_headers</a>(&amp;mut self, headers: <a class="struct" href="struct.ByteRecord.html" title="struct arrow2::io::csv::read_async::ByteRecord">ByteRecord</a>)</h4></section></summary><div class="docblock"><p>Set the headers of this CSV parser manually as raw bytes.</p>
<p>This overrides any other setting (including <code>set_headers</code>). Any
automatic detection of headers is disabled. This may be called at any
time.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>csv_async::{AsyncReader, ByteRecord};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(data.as_bytes());

    <span class="macro">assert_eq!</span>(rdr.byte_headers().<span class="kw">await</span><span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    rdr.set_byte_headers(ByteRecord::from(<span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]));
    <span class="macro">assert_eq!</span>(rdr.byte_headers().<span class="kw">await</span><span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_record" class="method"><h4 class="code-header">pub async fn <a href="#method.read_record" class="fn">read_record</a>(
    &amp;mut self,
    record: &amp;mut StringRecord
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, <a class="struct" href="struct.CSVError.html" title="struct arrow2::io::csv::read_async::CSVError">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Read a single row into the given record. Returns false when no more
records could be read.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this will treat initial row as headers and read the first data record.</p>
<p>This method is useful when you want to read records as fast as
as possible. It’s less ergonomic than an iterator, but it permits the
caller to reuse the <code>StringRecord</code> allocation, which usually results
in higher throughput.</p>
<p>Records read via this method are guaranteed to have a position set
on them, even if the reader is at EOF or if an error is returned.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>csv_async::{AsyncReader, StringRecord};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>record = StringRecord::new();

    <span class="kw">if </span>rdr.read_record(<span class="kw-2">&amp;mut </span>record).<span class="kw">await</span><span class="question-mark">? </span>{
        <span class="macro">assert_eq!</span>(record, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_byte_record" class="method"><h4 class="code-header">pub async fn <a href="#method.read_byte_record" class="fn">read_byte_record</a>(
    &amp;mut self,
    record: &amp;mut <a class="struct" href="struct.ByteRecord.html" title="struct arrow2::io::csv::read_async::ByteRecord">ByteRecord</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, <a class="struct" href="struct.CSVError.html" title="struct arrow2::io::csv::read_async::CSVError">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Read a single row into the given byte record. Returns false when no
more records could be read.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this will treat initial row as headers and read the first data record.</p>
<p>This method is useful when you want to read records as fast as
as possible. It’s less ergonomic than an iterator, but it permits the
caller to reuse the <code>ByteRecord</code> allocation, which usually results
in higher throughput.</p>
<p>Records read via this method are guaranteed to have a position set
on them, even if the reader is at EOF or if an error is returned.</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>csv_async::{ByteRecord, AsyncReader};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(data.as_bytes());
    <span class="kw">let </span><span class="kw-2">mut </span>record = ByteRecord::new();

    <span class="kw">if </span>rdr.read_byte_record(<span class="kw-2">&amp;mut </span>record).<span class="kw">await</span><span class="question-mark">? </span>{
        <span class="macro">assert_eq!</span>(record, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.position" class="method"><h4 class="code-header">pub fn <a href="#method.position" class="fn">position</a>(&amp;self) -&gt; &amp;Position</h4></section></summary><div class="docblock"><p>Return the current position of this CSV reader.</p>
<p>The byte offset in the position returned can be used to <code>seek</code> this
reader. In particular, seeking to a position returned here on the same
data will result in parsing the same subsequent record.</p>
<h5 id="example-reading-the-position"><a href="#example-reading-the-position">Example: reading the position</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::io;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::{AsyncReader, Position};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
    <span class="kw">let </span>rdr = AsyncReader::from_reader(io::Cursor::new(data));
    <span class="kw">let </span><span class="kw-2">mut </span>iter = rdr.into_records();
    <span class="kw">let </span><span class="kw-2">mut </span>pos = Position::new();
    <span class="kw">loop </span>{
        <span class="kw">let </span>next = iter.next().<span class="kw">await</span>;
        <span class="kw">if let </span><span class="prelude-val">Some</span>(next) = next {
            pos = next<span class="question-mark">?</span>.position().expect(<span class="string">&quot;Cursor should be at some valid position&quot;</span>).clone();
        } <span class="kw">else </span>{
            <span class="kw">break</span>;
        }
    }

    <span class="comment">// `pos` should now be the position immediately before the last
    // record.
    </span><span class="macro">assert_eq!</span>(pos.byte(), <span class="number">51</span>);
    <span class="macro">assert_eq!</span>(pos.line(), <span class="number">3</span>);
    <span class="macro">assert_eq!</span>(pos.record(), <span class="number">2</span>);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_done" class="method"><h4 class="code-header">pub fn <a href="#method.is_done" class="fn">is_done</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this reader has been exhausted.</p>
<p>When this returns true, no more records can be read from this reader
(unless it has been seeked to another position).</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::io;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::{AsyncReader, Position};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(io::Cursor::new(data));
    <span class="macro">assert!</span>(!rdr.is_done());
    {
        <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.records();
        <span class="kw">while let </span><span class="prelude-val">Some</span>(record) = records.next().<span class="kw">await </span>{
            <span class="kw">let _ </span>= record<span class="question-mark">?</span>;
        }
    }
    <span class="macro">assert!</span>(rdr.is_done());
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_headers" class="method"><h4 class="code-header">pub fn <a href="#method.has_headers" class="fn">has_headers</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this reader has been configured to
interpret the first record as a header record.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_ref" class="method"><h4 class="code-header">pub fn <a href="#method.get_ref" class="fn">get_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;R</a></h4></section></summary><div class="docblock"><p>Returns a reference to the underlying reader.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut R</a></h4></section></summary><div class="docblock"><p>Returns a mutable reference to the underlying reader.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_inner" class="method"><h4 class="code-header">pub fn <a href="#method.into_inner" class="fn">into_inner</a>(self) -&gt; R</h4></section></summary><div class="docblock"><p>Unwraps this CSV reader, returning the underlying reader.</p>
<p>Note that any leftover data inside this reader’s internal buffer is
lost.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsyncReader%3CR%3E-1" class="impl"><a href="#impl-AsyncReader%3CR%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="struct" href="struct.AsyncReader.html" title="struct arrow2::io::csv::read_async::AsyncReader">AsyncReader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: AsyncRead + AsyncSeek + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.seek" class="method"><h4 class="code-header">pub async fn <a href="#method.seek" class="fn">seek</a>(&amp;mut self, pos: Position) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.CSVError.html" title="struct arrow2::io::csv::read_async::CSVError">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Seeks the underlying reader to the position given.</p>
<p>This comes with a few caveats:</p>
<ul>
<li>Any internal buffer associated with this reader is cleared.</li>
<li>If the given position does not correspond to a position immediately
before the start of a record, then the behavior of this reader is
unspecified.</li>
<li>Any special logic that skips the first record in the CSV reader
when reading or iterating over records is disabled.</li>
</ul>
<p>If the given position has a byte offset equivalent to the current
position, then no seeking is performed.</p>
<p>If the header row has not already been read, then this will attempt
to read the header row before seeking. Therefore, it is possible that
this returns an error associated with reading CSV data.</p>
<p>Note that seeking is performed based only on the byte offset in the
given position. Namely, the record or line numbers in the position may
be incorrect, but this will cause any future position generated by
this CSV reader to be similarly incorrect.</p>
<h5 id="example-seek-to-parse-a-record-twice"><a href="#example-seek-to-parse-a-record-twice">Example: seek to parse a record twice</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::io;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::{AsyncReader, Position};

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(io::Cursor::new(data));
    <span class="kw">let </span><span class="kw-2">mut </span>pos = Position::new();
    {
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.records();
    <span class="kw">loop </span>{
        <span class="kw">let </span>next = records.next().<span class="kw">await</span>;
        <span class="kw">if let </span><span class="prelude-val">Some</span>(next) = next {
            pos = next<span class="question-mark">?</span>.position().expect(<span class="string">&quot;Cursor should be at some valid position&quot;</span>).clone();
        } <span class="kw">else </span>{
            <span class="kw">break</span>;
        }
    }
    }

    {
    <span class="comment">// Now seek the reader back to `pos`. This will let us read the
    // last record again.
    </span>rdr.seek(pos).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.into_records();
    <span class="kw">if let </span><span class="prelude-val">Some</span>(result) = records.next().<span class="kw">await </span>{
        <span class="kw">let </span>record = result<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(record, <span class="macro">vec!</span>[<span class="string">&quot;Concord&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;42695&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(From::from(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.seek_raw" class="method"><h4 class="code-header">pub async fn <a href="#method.seek_raw" class="fn">seek_raw</a>(
    &amp;mut self,
    seek_from: <a class="enum" href="https://doc.rust-lang.org/nightly/std/io/enum.SeekFrom.html" title="enum std::io::SeekFrom">SeekFrom</a>,
    pos: Position
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.CSVError.html" title="struct arrow2::io::csv::read_async::CSVError">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This is like <code>seek</code>, but provides direct control over how the seeking
operation is performed via <code>io::SeekFrom</code>.</p>
<p>The <code>pos</code> position given <em>should</em> correspond the position indicated
by <code>seek_from</code>, but there is no requirement. If the <code>pos</code> position
given is incorrect, then the position information returned by this
reader will be similarly incorrect.</p>
<p>If the header row has not already been read, then this will attempt
to read the header row before seeking. Therefore, it is possible that
this returns an error associated with reading CSV data.</p>
<p>Unlike <code>seek</code>, this will always cause an actual seek to be performed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rewind" class="method"><h4 class="code-header">pub async fn <a href="#method.rewind" class="fn">rewind</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.CSVError.html" title="struct arrow2::io::csv::read_async::CSVError">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Rewinds the underlying reader to first data record.</p>
<p>Function is aware of header presence.
After <code>rewind</code> record iterators will return first data record (skipping header if present), while
after <code>seek(0)</code> they will return header row (even if <code>has_header</code> is set).</p>
<h5 id="example-reads-the-same-data-multiply-times"><a href="#example-reads-the-same-data-multiply-times">Example: Reads the same data multiply times</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;
<span class="kw">use </span>futures::io;
<span class="kw">use </span>futures::stream::StreamExt;
<span class="kw">use </span>csv_async::AsyncReader;

<span class="kw">async fn </span>example() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>data = <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>rdr = AsyncReader::from_reader(io::Cursor::new(data));
    <span class="kw">let </span><span class="kw-2">mut </span>output = Vec::new();
    <span class="kw">loop </span>{
        <span class="kw">let </span><span class="kw-2">mut </span>records = rdr.records();
        <span class="kw">while let </span><span class="prelude-val">Some</span>(rec) = records.next().<span class="kw">await </span>{
            output.push(rec<span class="question-mark">?</span>);
        }
        <span class="kw">if </span>output.len() &gt;= <span class="number">6 </span>{
            <span class="kw">break</span>;
        } <span class="kw">else </span>{
            drop(records);
            rdr.rewind().<span class="kw">await</span><span class="question-mark">?</span>;
        }
    }
    <span class="macro">assert_eq!</span>(output,
        <span class="macro">vec!</span>[
            <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>],
            <span class="macro">vec!</span>[<span class="string">&quot;Concord&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;42695&quot;</span>],
            <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>],
            <span class="macro">vec!</span>[<span class="string">&quot;Concord&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;42695&quot;</span>],
            <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>],
            <span class="macro">vec!</span>[<span class="string">&quot;Concord&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;42695&quot;</span>],
        ]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-AsyncReader%3CR%3E" class="impl"><a href="#impl-Debug-for-AsyncReader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.AsyncReader.html" title="struct arrow2::io::csv::read_async::AsyncReader">AsyncReader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-AsyncReader%3CR%3E" class="impl"><a href="#impl-RefUnwindSafe-for-AsyncReader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.AsyncReader.html" title="struct arrow2::io::csv::read_async::AsyncReader">AsyncReader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-AsyncReader%3CR%3E" class="impl"><a href="#impl-Send-for-AsyncReader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.AsyncReader.html" title="struct arrow2::io::csv::read_async::AsyncReader">AsyncReader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</span></h3></section><section id="impl-Sync-for-AsyncReader%3CR%3E" class="impl"><a href="#impl-Sync-for-AsyncReader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.AsyncReader.html" title="struct arrow2::io::csv::read_async::AsyncReader">AsyncReader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section><section id="impl-Unpin-for-AsyncReader%3CR%3E" class="impl"><a href="#impl-Unpin-for-AsyncReader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.AsyncReader.html" title="struct arrow2::io::csv::read_async::AsyncReader">AsyncReader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-AsyncReader%3CR%3E" class="impl"><a href="#impl-UnwindSafe-for-AsyncReader%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.AsyncReader.html" title="struct arrow2::io::csv::read_async::AsyncReader">AsyncReader</a>&lt;R&gt;<span class="where fmt-newline">where
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#135">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#136">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#763">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#766">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#756">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#803-805">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#810">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788-790">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#795">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Allocation-for-T" class="impl"><a href="#impl-Allocation-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Allocation for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section></div></section></div></main></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="APIs to read from and write to Arrow’s IPC format."><title>arrow2::io::ipc - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-2fcac8296ac587d8.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="arrow2" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (8b35c0bb0 2023-06-08)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-48600a9606eff342.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../arrow2/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../arrow2/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module ipc</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">arrow2</a>::<wbr><a href="../index.html">io</a>::<wbr><a class="mod" href="#">ipc</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/arrow2/io/ipc/mod.rs.html#1-103">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>io_ipc</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>APIs to read from and write to Arrow’s IPC format.</p>
<p>Inter-process communication is a method through which different processes
share and pass data between them. Its use-cases include parallel
processing of chunks of data across different CPU cores, transferring
data between different Apache Arrow implementations in other languages and
more. Under the hood Apache Arrow uses <a href="https://google.github.io/flatbuffers/">FlatBuffers</a>
as its binary protocol, so every Arrow-centered streaming or serialiation
problem that could be solved using FlatBuffers could probably be solved
using the more integrated approach that is exposed in this module.</p>
<p><a href="https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc">Arrow’s IPC protocol</a>
allows only batch or dictionary columns to be passed
around due to its reliance on a pre-defined data scheme. This constraint
provides a large performance gain because serialized data will always have a
known structutre, i.e. the same fields and datatypes, with the only variance
being the number of rows and the actual data inside the Batch. This dramatically
increases the deserialization rate, as the bytes in the file or stream are already
structured “correctly”.</p>
<p>Reading and writing IPC messages is done using one of two variants - either
<a href="read/struct.FileReader.html" title="struct arrow2::io::ipc::read::FileReader"><code>FileReader</code></a> &lt;-&gt; <a href="write/struct.FileWriter.html" title="struct arrow2::io::ipc::write::FileWriter"><code>FileWriter</code></a> or
<a href="read/struct.StreamReader.html" title="struct arrow2::io::ipc::read::StreamReader"><code>StreamReader</code></a> &lt;-&gt; <a href="write/struct.StreamWriter.html" title="struct arrow2::io::ipc::write::StreamWriter"><code>StreamWriter</code></a>.
These two variants wrap a type <code>T</code> that implements <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read"><code>Read</code></a>, and in
the case of the <code>File</code> variant it also implements <a href="https://doc.rust-lang.org/nightly/std/io/trait.Seek.html" title="trait std::io::Seek"><code>Seek</code></a>. In
practice it means that <code>File</code>s can be arbitrarily accessed while <code>Stream</code>s are only
read in certain order - the one they were written in (first in, first out).</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>Read and write to a file:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>arrow2::io::ipc::{{read::{FileReader, read_file_metadata}}, {write::{FileWriter, WriteOptions}}};
<span class="comment">// Setup the writer
</span><span class="kw">let </span>path = <span class="string">&quot;example.arrow&quot;</span>.to_string();
<span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="kw-2">&amp;</span>path)<span class="question-mark">?</span>;
<span class="kw">let </span>x_coord = Field::new(<span class="string">&quot;x&quot;</span>, DataType::Int32, <span class="bool-val">false</span>);
<span class="kw">let </span>y_coord = Field::new(<span class="string">&quot;y&quot;</span>, DataType::Int32, <span class="bool-val">false</span>);
<span class="kw">let </span>schema = Schema::from(<span class="macro">vec!</span>[x_coord, y_coord]);
<span class="kw">let </span>options = WriteOptions {compression: <span class="prelude-val">None</span>};
<span class="kw">let </span><span class="kw-2">mut </span>writer = FileWriter::try_new(file, schema, <span class="prelude-val">None</span>, options)<span class="question-mark">?</span>;

<span class="comment">// Setup the data
</span><span class="kw">let </span>x_data = Int32Array::from_slice([-<span class="number">1i32</span>, <span class="number">1</span>]);
<span class="kw">let </span>y_data = Int32Array::from_slice([<span class="number">1i32</span>, -<span class="number">1</span>]);
<span class="kw">let </span>chunk = Chunk::try_new(<span class="macro">vec!</span>[x_data.boxed(), y_data.boxed()])<span class="question-mark">?</span>;

<span class="comment">// Write the messages and finalize the stream
</span><span class="kw">for _ in </span><span class="number">0</span>..<span class="number">5 </span>{
    writer.write(<span class="kw-2">&amp;</span>chunk, <span class="prelude-val">None</span>);
}
writer.finish();

<span class="comment">// Fetch some of the data and get the reader back
</span><span class="kw">let </span><span class="kw-2">mut </span>reader = File::open(<span class="kw-2">&amp;</span>path)<span class="question-mark">?</span>;
<span class="kw">let </span>metadata = read_file_metadata(<span class="kw-2">&amp;mut </span>reader)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>reader = FileReader::new(reader, metadata, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>);
<span class="kw">let </span>row1 = reader.next().unwrap();  <span class="comment">// [[-1, 1], [1, -1]]
</span><span class="kw">let </span>row2 = reader.next().unwrap();  <span class="comment">// [[-1, 1], [1, -1]]
</span><span class="kw">let </span><span class="kw-2">mut </span>reader = reader.into_inner();
<span class="comment">// Do more stuff with the reader, like seeking ahead.</span></code></pre></div>
<p>For further information and examples please consult the
<a href="https://jorgecarleitao.github.io/arrow2/io/index.html">user guide</a>.
For even more examples check the <code>examples</code> folder in the main repository
(<a href="https://github.com/jorgecarleitao/arrow2/blob/main/examples/ipc_file_read.rs">1</a>,
<a href="https://github.com/jorgecarleitao/arrow2/blob/main/examples/ipc_file_write.rs">2</a>,
<a href="https://github.com/jorgecarleitao/arrow2/tree/main/examples/ipc_pyarrow">3</a>).</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="append/index.html" title="mod arrow2::io::ipc::append">append</a></div><div class="desc docblock-short">A struct adapter of Read+Seek+Write to append to IPC files</div></li><li><div class="item-name"><a class="mod" href="read/index.html" title="mod arrow2::io::ipc::read">read</a></div><div class="desc docblock-short">APIs to read Arrow’s IPC format.</div></li><li><div class="item-name"><a class="mod" href="write/index.html" title="mod arrow2::io::ipc::write">write</a></div><div class="desc docblock-short">APIs to write to Arrow’s IPC format.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.IpcField.html" title="struct arrow2::io::ipc::IpcField">IpcField</a></div><div class="desc docblock-short">Struct containing <code>dictionary_id</code> and nested <code>IpcField</code>, allowing users
to specify the dictionary ids of the IPC fields when writing to IPC.</div></li><li><div class="item-name"><a class="struct" href="struct.IpcSchema.html" title="struct arrow2::io::ipc::IpcSchema">IpcSchema</a></div><div class="desc docblock-short">Struct containing fields and whether the file is written in little or big endian.</div></li></ul></section></div></main></body></html>
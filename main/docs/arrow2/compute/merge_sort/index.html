<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Functions to perform merge-sorts."><title>arrow2::compute::merge_sort - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-8092eaa720ad3b6f.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="arrow2" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (8084f397c 2023-06-25)" data-channel="nightly" data-search-js="search-c507e026dd61038c.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../arrow2/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../arrow2/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module merge_sort</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">arrow2</a>::<wbr><a href="../index.html">compute</a>::<wbr><a class="mod" href="#">merge_sort</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/arrow2/compute/merge_sort/mod.rs.html#1-544">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>compute_merge_sort</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Functions to perform merge-sorts.</p>
<p>The goal of merge-sort is to merge two sorted arrays, <code>[a0, a1]</code>, <code>merge_sort(a0, a1)</code>,
so that the resulting array is sorted, i.e. the following invariant upholds:
<code>sort(merge_sort(a0, a1)) == merge_sort(a0, a1)</code> for any two sorted arrays <code>a0</code> and <code>a1</code>.</p>
<p>Given that two sorted arrays are more likely to be partially sorted within each other,
and that the resulting array is built by taking elements from each array, it is
advantageous to <code>take</code> slices of items, not items, from each array.
As such, this module’s main data representation is <code>(i: usize, start: usize, len: usize)</code>,
which represents a slice of array <code>i</code>.</p>
<p>In this context, <code>merge_sort</code> is composed by two main operations:</p>
<ol>
<li>compute the array of slices <code>v</code> that construct a new sorted array from <code>a0</code> and <code>a1</code>.</li>
<li><code>take_arrays</code> from <code>a0</code> and <code>a1</code>, creating the sorted array.</li>
</ol>
<p>In the extreme case where the two arrays are already sorted between then (e.g. <code>[0, 2]</code>, <code>[3, 4]</code>),
we need two slices, <code>v = vec![(0, 0, a0.len()), (1, 0, a1.len())]</code>. The higher the
inter-leave between the two arrays, the more slices will be needed, and
generally the more expensive the <code>take</code> operation will be.</p>
<h3 id="merge-sort-multiple-arrays"><a href="#merge-sort-multiple-arrays">Merge-sort multiple arrays</a></h3>
<p>The main advantage of merge-sort over <code>sort</code> is that it can be parallelized.
For example, given a set of arrays <code>[a0, a1, a2, a3]</code> representing the same field,
e.g. over 4 batches of arrays, they can be sorted in parallel as follows (pseudo-code):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// in parallel
</span><span class="kw">let </span>a0 = sort(a0);
<span class="kw">let </span>a1 = sort(a1);
<span class="kw">let </span>a2 = sort(a2);
<span class="kw">let </span>a3 = sort(a3);

<span class="comment">// in parallel and recursively
</span><span class="kw">let </span>slices1 = merge_sort_slices(a0, a1);
<span class="kw">let </span>slices2 = merge_sort_slices(a2, a3);
<span class="kw">let </span>slices = merge_sort_slices(slices1, slices2);

<span class="kw">let </span>array = take_arrays(<span class="kw-2">&amp;</span>[a0, a1, a2, a3], slices, <span class="prelude-val">None</span>);</code></pre></div>
<p>A common operation in query engines is to merge multiple fields based on the
same sorting field (e.g. merge-sort multiple batches of arrays).
To perform this, use the same idea as above, but use <code>take_arrays</code> over
each independent field (which can again be parallelized):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// `slices` computed before-hand
// in parallel
</span><span class="kw">let </span>array1 = take_arrays(<span class="kw-2">&amp;</span>[a0, a1, a2, a3], slices, <span class="prelude-val">None</span>);
<span class="kw">let </span>array2 = take_arrays(<span class="kw-2">&amp;</span>[b0, b1, b2, b3], slices, <span class="prelude-val">None</span>);</code></pre></div>
<p>To serialize slices, e.g. for checkpointing or transfer via Arrow’s IPC, you can store
them as 3 non-null primitive arrays (e.g. <code>PrimitiveArray&lt;i64&gt;</code>).</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.SortOptions"><code>pub use crate::compute::sort::<a class="struct" href="../sort/struct.SortOptions.html" title="struct arrow2::compute::sort::SortOptions">SortOptions</a>;</code></div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.MergeSortSlices.html" title="struct arrow2::compute::merge_sort::MergeSortSlices">MergeSortSlices</a></div><div class="desc docblock-short">An iterator adapter that merge-sorts two iterators of <code>MergeSlice</code> into a single <code>MergeSlice</code>
such that the resulting <code>MergeSlice</code>s are ordered according to <code>comparator</code>.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.build_comparator.html" title="fn arrow2::compute::merge_sort::build_comparator">build_comparator</a></div><div class="desc docblock-short">returns a comparison function between any two arrays of each pair of arrays, according to <code>SortOptions</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.build_comparator_impl.html" title="fn arrow2::compute::merge_sort::build_comparator_impl">build_comparator_impl</a></div><div class="desc docblock-short">returns a comparison function between any two arrays of each pair of arrays, according to <code>SortOptions</code>.
Implementing custom <code>build_compare_fn</code> for unsupportd data types.</div></li><li><div class="item-name"><a class="fn" href="fn.merge_sort.html" title="fn arrow2::compute::merge_sort::merge_sort">merge_sort</a></div><div class="desc docblock-short">Combines two sorted <a href="../../array/trait.Array.html" title="trait arrow2::array::Array">Array</a>s of the same <a href="../../datatypes/enum.DataType.html" title="enum arrow2::datatypes::DataType"><code>crate::datatypes::DataType</code></a> into a single sorted array.
If the arrays are not sorted (which this function does not check), the result is wrong.</div></li><li><div class="item-name"><a class="fn" href="fn.merge_sort_slices.html" title="fn arrow2::compute::merge_sort::merge_sort_slices">merge_sort_slices</a></div><div class="desc docblock-short">Given two iterators of slices representing two sets of sorted <a href="../../array/trait.Array.html" title="trait arrow2::array::Array"><code>Array</code></a>s, and a <code>comparator</code> bound to those <a href="../../array/trait.Array.html" title="trait arrow2::array::Array"><code>Array</code></a>s,
returns a new iterator of slices denoting how to <code>take</code> slices from each of the arrays such that the resulting
array is sorted according to <code>comparator</code></div></li><li><div class="item-name"><a class="fn" href="fn.slices.html" title="fn arrow2::compute::merge_sort::slices">slices</a></div><div class="desc docblock-short">Returns a vector of slices from different sorted arrays that can be used to create sorted arrays.
<code>pairs</code> is an array representing multiple sorted array sets. The expected format is</div></li><li><div class="item-name"><a class="fn" href="fn.take_arrays.html" title="fn arrow2::compute::merge_sort::take_arrays">take_arrays</a></div><div class="desc docblock-short">Takes N arrays together through <code>slices</code> under the assumption that the slices have
a total coverage of the arrays.
I.e. they are such that all elements on all arrays are picked (which is the case in sorting).</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.MergeSlice.html" title="type arrow2::compute::merge_sort::MergeSlice">MergeSlice</a></div><div class="desc docblock-short">A slice denoting <code>(array_index, start, len)</code> representing a slice from one of N arrays.
This is used to keep track of contiguous blocks of slots.
An array of MergeSlice, <code>[MergeSlice]</code>, represents inter-leaved array slices.
For example, <code>[(0, 0, 2), (1, 0, 1), (0, 2, 3)]</code> represents 2 arrays (a0 and a1) arranged as follows:
<code>[a0[0..2], a1[0..1], a0[2..3]]</code>
This representation is useful when building arrays in memory as it allows to memcopy slices of arrays.
This is particularly useful in merge-sort because sorted arrays (passed to the merge-sort) are more likely
to have contiguous blocks of sorted elements (than by random).</div></li></ul></section></div></main></body></html>